/**
 * 修复版主程序 - 真正的3D场景
 */
class BasicPoolScene {
    constructor() {
        this.canvas = document.getElementById('webgl-canvas');
        this.gl = this.canvas.getContext('webgl2');
        
        if (!this.gl) {
            alert('浏览器不支持WebGL2！');
            return;
        }

        this.objects = {};
        this.buffers = {};
        this.program = null;
        
        this.init();
    }

    init() {
        this.setupWebGL();
        this.createShaders();      // 使用带光照的着色器
        this.createGeometries();
        this.createSceneObjects();
        this.render();
    }

    setupWebGL() {
        const gl = this.gl;
        gl.clearColor(0.1, 0.1, 0.2, 1.0);
        gl.enable(gl.DEPTH_TEST);  // 启用深度测试，实现3D遮挡
        gl.enable(gl.CULL_FACE);   // 启用背面剔除，提高性能
        gl.clearDepth(1.0);
    }

    /**
     * 使用带光照的着色器，让球体看起来是3D的
     */
    createShaders() {
        const gl = this.gl;
        
        // 带光照的顶点着色器
        const vertexShaderSource = `#version 300 es
            in vec4 aPosition;
            in vec3 aNormal;        // 新增：法线向量
            
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uNormalMatrix;  // 新增：法线变换矩阵
            
            out vec3 vNormal;       // 向片元着色器传递法线
            out vec3 vPosition;     // 向片元着色器传递位置
            
            void main() {
                gl_Position = uProjectionMatrix * uModelViewMatrix * aPosition;
                vNormal = mat3(uNormalMatrix) * aNormal;  // 变换法线
                vPosition = vec3(uModelViewMatrix * aPosition);
            }
        `;
        
        // 带光照的片元着色器 - 实现简单的3D光照效果
        const fragmentShaderSource = `#version 300 es
            precision highp float;
            
            in vec3 vNormal;
            in vec3 vPosition;
            
            uniform vec3 uColor;
            uniform vec3 uLightPosition;  // 光源位置
            uniform vec3 uLightColor;     // 光源颜色
            
            out vec4 fragColor;
            
            void main() {
                // 环境光 - 基础照明
                vec3 ambient = uColor * 0.3;
                
                // 漫反射 - 主要的光照效果
                vec3 normal = normalize(vNormal);
                vec3 lightDir = normalize(uLightPosition - vPosition);
                float diff = max(dot(normal, lightDir), 0.0);
                vec3 diffuse = diff * uColor * uLightColor;
                
                // 组合光照
                vec3 result = ambient + diffuse;
                fragColor = vec4(result, 1.0);
            }
        `;

        // 编译着色器（代码同上）
        const vertexShader = this.compileShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = this.compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
        
        this.program = gl.createProgram();
        gl.attachShader(this.program, vertexShader);
        gl.attachShader(this.program, fragmentShader);
        gl.linkProgram(this.program);
        
        gl.useProgram(this.program);
        
        // 获取attribute和uniform位置
        this.attribLocations = {
            position: gl.getAttribLocation(this.program, 'aPosition'),
            normal: gl.getAttribLocation(this.program, 'aNormal')  // 新增法线
        };
        
        this.uniformLocations = {
            modelViewMatrix: gl.getUniformLocation(this.program, 'uModelViewMatrix'),
            projectionMatrix: gl.getUniformLocation(this.program, 'uProjectionMatrix'),
            normalMatrix: gl.getUniformLocation(this.program, 'uNormalMatrix'), // 新增
            color: gl.getUniformLocation(this.program, 'uColor'),
            lightPosition: gl.getUniformLocation(this.program, 'uLightPosition'),
            lightColor: gl.getUniformLocation(this.program, 'uLightColor')
        };
    }

    /**
     * 创建带法线的球体几何数据
     */
    createSphereBuffer(latBands, longBands) {
        const gl = this.gl;
        const vertices = [];
        const indices = [];
        
        for (let lat = 0; lat <= latBands; lat++) {
            const theta = lat * Math.PI / latBands;
            const sinTheta = Math.sin(theta);
            const cosTheta = Math.cos(theta);
            
            for (let lon = 0; lon <= longBands; lon++) {
                const phi = lon * 2 * Math.PI / longBands;
                const sinPhi = Math.sin(phi);
                const cosPhi = Math.cos(phi);
                
                // 顶点位置
                const x = cosPhi * sinTheta;
                const y = cosTheta;
                const z = sinPhi * sinTheta;
                
                // 位置坐标 (x, y, z) + 法线坐标 (nx, ny, nz)
                // 球体的法线就是从球心指向表面的向量，所以和位置坐标一样
                vertices.push(
                    x * 0.5, y * 0.5, z * 0.5,  // 位置
                    x, y, z                      // 法线
                );
            }
        }
        
        // 生成三角形索引（同上）
        for (let lat = 0; lat < latBands; lat++) {
            for (let lon = 0; lon < longBands; lon++) {
                const first = (lat * (longBands + 1)) + lon;
                const second = first + longBands + 1;
                indices.push(first, second, first + 1);
                indices.push(second, second + 1, first + 1);
            }
        }
        
        return this.createGPUBuffer(new Float32Array(vertices), new Uint16Array(indices), true);
    }

    /**
     * 创建带法线的立方体
     */
    createCubeBuffer() {
        const gl = this.gl;
        
        // 位置坐标 + 法线坐标 (每个顶点6个值)
        const vertices = new Float32Array([
            // 前面
            -0.5, -0.5,  0.5,  0.0,  0.0,  1.0,
             0.5, -0.5,  0.5,  0.0,  0.0,  1.0,
             0.5,  0.5,  0.5,  0.0,  0.0,  1.0,
            -0.5,  0.5,  0.5,  0.0,  0.0,  1.0,
            
            // 后面
            -0.5, -0.5, -0.5,  0.0,  0.0, -1.0,
            -0.5,  0.5, -0.5,  0.0,  0.0, -1.0,
             0.5,  0.5, -0.5,  0.0,  0.0, -1.0,
             0.5, -0.5, -0.5,  0.0,  0.0, -1.0,
            
            // 上面
            -0.5,  0.5, -0.5,  0.0,  1.0,  0.0,
            -0.5,  0.5,  0.5,  0.0,  1.0,  0.0,
             0.5,  0.5,  0.5,  0.0,  1.0,  0.0,
             0.5,  0.5, -0.5,  0.0,  1.0,  0.0,
            
            // 下面
            -0.5, -0.5, -0.5,  0.0, -1.0,  0.0,
             0.5, -0.5, -0.5,  0.0, -1.0,  0.0,
             0.5, -0.5,  0.5,  0.0, -1.0,  0.0,
            -0.5, -0.5,  0.5,  0.0, -1.0,  0.0,
            
            // 右面
             0.5, -0.5, -0.5,  1.0,  0.0,  0.0,
             0.5,  0.5, -0.5,  1.0,  0.0,  0.0,
             0.5,  0.5,  0.5,  1.0,  0.0,  0.0,
             0.5, -0.5,  0.5,  1.0,  0.0,  0.0,
            
            // 左面
            -0.5, -0.5, -0.5, -1.0,  0.0,  0.0,
            -0.5, -0.5,  0.5, -1.0,  0.0,  0.0,
            -0.5,  0.5,  0.5, -1.0,  0.0,  0.0,
            -0.5,  0.5, -0.5, -1.0,  0.0,  0.0
        ]);

        const indices = new Uint16Array([
            // 前面
            0, 1, 2,  0, 2, 3,
            // 后面
            4, 5, 6,  4, 6, 7,
            // 上面
            8, 9, 10, 8, 10, 11,
            // 下面
            12, 13, 14, 12, 14, 15,
            // 右面
            16, 17, 18, 16, 18, 19,
            // 左面
            20, 21, 22, 20, 22, 23
        ]);

        return this.createGPUBuffer(vertices, indices, true);
    }

    /**
     * 改进的GPU缓冲区创建，支持法线数据
     */
    createGPUBuffer(vertices, indices, hasNormals = false) {
        const gl = this.gl;
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        
        // 顶点缓冲区
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        
        // 设置位置属性
        gl.enableVertexAttribArray(this.attribLocations.position);
        const stride = hasNormals ? 24 : 12; // 有法线时每顶点6个float(24字节)
        gl.vertexAttribPointer(this.attribLocations.position, 3, gl.FLOAT, false, stride, 0);
        
        // 设置法线属性（如果有）
        if (hasNormals) {
            gl.enableVertexAttribArray(this.attribLocations.normal);
            gl.vertexAttribPointer(this.attribLocations.normal, 3, gl.FLOAT, false, stride, 12);
        }
        
        // 索引缓冲区
        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        
        gl.bindVertexArray(null);
        
        return {
            vao: vao,
            vertexCount: indices.length
        };
    }

    /**
     * 调整物体位置，让它们在画面中央
     */
    createSceneObjects() {
        // 台球桌 - 调整到画面中央
        this.objects.table = {
            type: 'cube',
            position: [0, 0, -0.5],  // 向后移动一点
            scale: [2.5, 1.2, 0.1],   // 调整大小
            color: [0.1, 0.5, 0.1]
        };
        
        // 球体 - 重新排列位置
        this.objects.whiteBall = {
            type: 'sphere',
            position: [-0.8, 0, 0.2],  // 向左移动
            scale: [0.2, 0.2, 0.2],    // 稍微放大
            color: [1, 1, 1]
        };
        
        this.objects.blackBall = {
            type: 'sphere', 
            position: [0.8, 0, 0.2],   // 向右移动
            scale: [0.2, 0.2, 0.2],
            color: [0.1, 0.1, 0.1]
        };
        
        this.objects.redBall = {
            type: 'sphere',
            position: [0, 0.4, 0.2],   // 向上移动
            scale: [0.2, 0.2, 0.2],
            color: [1, 0, 0]
        };
        
        this.objects.blueBall = {
            type: 'sphere',
            position: [0, -0.4, 0.2],  // 向下移动
            scale: [0.2, 0.2, 0.2],
            color: [0, 0, 1]
        };
    }

    /**
     * 改进的渲染循环 - 调整相机和添加光照
     */
    render() {
        const gl = this.gl;
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
        // 投影矩阵 - 视野角度调小一点
        const projectionMatrix = Matrix4.create();
        Matrix4.perspective(projectionMatrix, 
            Math.PI/3,  // 60度视野，看得更广
            this.canvas.width/this.canvas.height,
            0.1,
            100.0
        );
        
        // 视图矩阵 - 调整相机位置到更好的角度
        const viewMatrix = Matrix4.create();
        // 相机位置：向右0.5，向上1.5，向后4 - 从斜上方观看
        Matrix4.translate(viewMatrix, viewMatrix, [-0.5, -1.5, -4]);
        // 让相机稍微向下看
        Matrix4.rotateX(viewMatrix, viewMatrix, -0.3);
        
        // 设置光照
        gl.uniform3f(this.uniformLocations.lightPosition, 2, 3, 2); // 右上前方的光源
        gl.uniform3f(this.uniformLocations.lightColor, 1.0, 1.0, 1.0); // 白色光
        
        // 渲染所有物体
        this.renderObject(this.objects.table, viewMatrix, projectionMatrix);
        this.renderObject(this.objects.whiteBall, viewMatrix, projectionMatrix);
        this.renderObject(this.objects.blackBall, viewMatrix, projectionMatrix);
        this.renderObject(this.objects.redBall, viewMatrix, projectionMatrix);
        this.renderObject(this.objects.blueBall, viewMatrix, projectionMatrix);
        
        requestAnimationFrame(() => this.render());
    }

    /**
     * 改进的物体渲染，包含法线矩阵计算
     */
    renderObject(obj, viewMatrix, projectionMatrix) {
        const gl = this.gl;
        
        // 模型矩阵
        let modelMatrix = Matrix4.create();
        Matrix4.translate(modelMatrix, modelMatrix, obj.position);
        
        // 缩放矩阵
        const scaleMatrix = Matrix4.create();
        scaleMatrix[0] = obj.scale[0];
        scaleMatrix[5] = obj.scale[1];
        scaleMatrix[10] = obj.scale[2];
        Matrix4.multiply(modelMatrix, modelMatrix, scaleMatrix);
        
        // 模型视图矩阵
        const modelViewMatrix = Matrix4.create();
        Matrix4.multiply(modelViewMatrix, viewMatrix, modelMatrix);
        
        // 法线矩阵 - 用于正确变换法线向量
        const normalMatrix = Matrix4.create();
        Matrix4.multiply(normalMatrix, modelViewMatrix, modelViewMatrix); // 简化计算
        
        // 传递矩阵到着色器
        gl.uniformMatrix4fv(this.uniformLocations.modelViewMatrix, false, modelViewMatrix);
        gl.uniformMatrix4fv(this.uniformLocations.projectionMatrix, false, projectionMatrix);
        gl.uniformMatrix4fv(this.uniformLocations.normalMatrix, false, normalMatrix);
        
        // 设置物体颜色
        gl.uniform3f(this.uniformLocations.color, ...obj.color);
        
        // 绘制
        const buffer = this.buffers[obj.type];
        gl.bindVertexArray(buffer.vao);
        gl.drawElements(gl.TRIANGLES, buffer.vertexCount, gl.UNSIGNED_SHORT, 0);
        gl.bindVertexArray(null);
    }
}

// 启动场景
window.addEventListener('load', () => {
    new BasicPoolScene();
});
